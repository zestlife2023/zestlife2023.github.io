<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>封面制作与 EPUB 替换工具</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
        .container { display: flex; gap: 40px; max-width: 1800px; margin: 0 auto; }
        .controls { width: 400px; background: white; padding: 25px; border-radius: 10px; box-shadow: 0 3px 8px rgba(0,0,0,0.15); position: sticky; top: 40px; align-self: flex-start; }
        .preview { flex-grow: 1; display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 40px; }
        .preview-item { padding: 20px; background: white; border: 1px solid #eee; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; flex-direction: column; align-items: flex-start; position: relative; margin-bottom: 10px; }
        canvas { max-width: 100%; width: calc(100% * var(--preview-scale, 1)); border: 1px solid #ccc; border-radius: 3px; margin-top: 40px; margin-left: 0; }
        .param-group { padding: 10px 0; }
        .param-item { display: flex; align-items: center; margin-bottom: 3px; gap: 15px; padding: 4px 0; }
        .param-item label { flex: 0 0 80px; margin: 0; font-size: 14px; white-space: nowrap; line-height: 1.5; }
        .param-item .input-group { display: flex; flex-direction: row; align-items: center; gap: 10px; flex: 1; flex-wrap: nowrap; }
        .param-item input[type="number"], 
        .param-item input[type="text"], 
        .param-item input[type="color"], 
        .param-item select { width: 80px; padding: 4px; border-radius: 4px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; vertical-align: middle; }
        .param-item input[type="range"] { flex: 1; min-width: 150px; margin: 0; vertical-align: middle; }
        .param-item input[type="color"] { height: 30px; padding: 0; vertical-align: middle; }
        button { margin: 10px 20px 10px 0; padding: 12px 25px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; display: inline-flex; align-items: center; gap: 10px; font-size: 18px; }
        button:hover { background: #0056b3; }
        .download-group { display: inline-flex; align-items: center; gap: 10px; }
        #downloadMode { padding: 8px; border-radius: 3px; border: 1px solid #ccc; font-size: 16px; }
        #loading { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px; background: rgba(0,0,0,0.8); color: white; border-radius: 5px; }
        #dropZone { 
            width: 100%; 
            height: 180px; 
            border: 2px dashed #007bff; 
            border-radius: 12px; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            background: #e6f0ff; 
            margin-bottom: 40px; 
            transition: all 0.3s ease; 
            cursor: pointer; 
        }
        #dropZone.dragover { background: #cce0ff; border-color: #0056b3; }
        #dropZone span { font-size: 24px; color: #007bff; margin-top: 20px; }
        #dropZone input[type="file"] { display: none; }
        .status { margin-top: 20px; }
        .delete-btn {
            position: absolute;
            top: -30px;
            right: 5px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 10;
        }
        .delete-btn:hover { background: #c82333; }

        /* 预览区域内部样式调整 */
        .preview-item label {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            width: 100%; /* 确保label占满容器宽度 */
        }
        .preview-item label > span {
            flex: 0 0 120px; /* 固定label宽度 */
            text-align: left;
            margin-right: 15px;
            font-size: 14px;
            white-space: nowrap;
        }
        .preview-item input[type="text"],
        .preview-item select {
            flex: 1; /* 占满剩余空间 */
            min-width: 0; /* 防止flex元素溢出 */
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 14px;
            box-sizing: border-box;
            word-break: break-all; /* 长文字换行 */
        }
        .preview-item .crop-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 5px;
            width: 100%;
        }
        .preview-item .crop-controls label {
            margin-bottom: 0;
        }

        @media (max-width: 768px) {
            body { margin: 10px; }
            .container { flex-direction: column; gap: 20px; }
            .controls { width: 100%; position: static; padding: 15px; }
            .preview { grid-template-columns: 1fr; gap: 20px; }
            .preview-item { padding: 15px; position: relative; }
            .param-item { 
                flex-direction: column; 
                align-items: flex-start; 
                margin-bottom: 10px; 
                gap: 5px; 
                padding: 6px 0; 
            }
            .param-item label { flex: none; width: auto; }
            .param-item .input-group { 
                flex-direction: column; 
                width: 100%; 
                max-width: none; 
                gap: 5px; 
            }
            .param-item input[type="number"], 
            .param-item input[type="text"], 
            .param-item input[type="color"], 
            .param-item select, 
            .param-item input[type="range"] { 
                width: 100%; 
                max-width: none; 
            }
            .param-item input[type="range"] { min-width: 0; }
            button { padding: 8px 15px; font-size: 14px; margin: 5px 10px 5px 0; gap: 5px; }
            #downloadMode { padding: 6px; font-size: 14px; }
            #dropZone { height: 100px; margin-bottom: 20px; }
            #dropZone span { font-size: 16px; margin-top: 10px; }
            #dropZone i { font-size: 30px; }
            .delete-btn { top: -25px; right: 5px; width: 25px; height: 25px; font-size: 12px; }
            
            /* 预览区域移动端调整 */
            .preview-item label {
                flex-direction: column; /* 垂直排列 */
                align-items: flex-start;
            }
            .preview-item label > span {
                flex: none;
                width: auto;
                text-align: left;
                margin-right: 0;
                margin-bottom: 5px;
            }
            .preview-item input[type="text"],
            .preview-item select {
                width: 100%; /* 强制全宽 */
                flex: none;
                word-break: break-all; /* 确保长文字换行 */
                overflow: hidden; /* 防止溢出 */
                box-sizing: border-box;
            }
            .preview-item .crop-controls {
                gap: 8px;
            }
            .preview-item canvas {
                margin-top: 30px;
            }
        }

        /* EPUB选择封面窗口样式 */
        .modal-content { padding: 15px; }
        #coverOptions { display: flex; flex-wrap: wrap; gap: 10px; }
        .cover-option { cursor: pointer; text-align: center; }
        .cover-option img { max-width: 150px; max-height: 150px; object-fit: contain; border: 1px solid #ccc; border-radius: 3px; }
        .cover-option p { margin: 5px 0 0; font-size: 12px; color: #666; }
        .cover-option.selected img { border-color: #007bff; }
    </style>
</head>
<body>
    <h2>封面制作与 EPUB 替换工具</h2>
    <div id="dropZone">
        <i class="fas fa-cloud-upload-alt" style="font-size: 60px; color: #007bff;"></i>
        <span>拖拽图片或EPUB文件到此处，或点击选择文件</span>
        <input type="file" id="imageInput" multiple accept="image/*,.epub">
    </div>
    <div class="container">
        <div class="controls">
            <div class="param-group">
                <h4>全局参数</h4>
                <div class="param-item">
                    <label>书名大小:</label>
                    <div class="input-group">
                        <input type="number" id="titleSize" value="160" min="50" max="300">
                        <input type="range" id="titleSizeRange" min="50" max="300" value="160">
                    </div>
                </div>
                <div class="param-item">
                    <label>作者大小:</label>
                    <div class="input-group">
                        <input type="number" id="authorSize" value="100" min="30" max="200">
                        <input type="range" id="authorSizeRange" min="30" max="200" value="100">
                    </div>
                </div>
                <div class="param-item">
                    <label>行间距:</label>
                    <div class="input-group">
                        <input type="number" id="lineSpacing" value="100" min="0" max="200">
                        <input type="range" id="lineSpacingRange" min="0" max="200" value="100">
                    </div>
                </div>
                <div class="param-item">
                    <label>顶部空白:</label>
                    <div class="input-group">
                        <input type="number" id="topSpace" value="500" min="100" max="1000">
                        <input type="range" id="topSpaceRange" min="100" max="1000" value="500">
                    </div>
                </div>
                <div class="param-item">
                    <label>左边距:</label>
                    <div class="input-group">
                        <input type="number" id="leftMargin" value="60" min="0" max="500">
                        <input type="range" id="leftMarginRange" min="0" max="500" value="60">
                    </div>
                </div>
                <div class="param-item">
                    <label>输出宽度:</label>
                    <div class="input-group">
                        <input type="number" id="outputWidth" value="1860" min="500" max="2000">
                        <input type="range" id="outputWidthRange" min="500" max="2000" value="1860">
                    </div>
                </div>
                <div class="param-item">
                    <label>宽高比:</label>
                    <div class="input-group">
                        <input type="number" id="aspectRatio" value="0.75" min="0.5" max="1" step="0.01">
                        <input type="range" id="aspectRatioRange" min="0.5" max="1" step="0.01" value="0.75">
                    </div>
                </div>
                <div class="param-item">
                    <label>背景颜色:</label>
                    <div class="input-group">
                        <input type="color" id="bgColor" value="#ffffff">
                    </div>
                </div>
                <div class="param-item">
                    <label>文字颜色:</label>
                    <div class="input-group">
                        <input type="color" id="textColor" value="#000000">
                    </div>
                </div>
                <div class="param-item">
                    <label>图片处理:</label>
                    <div class="input-group">
                        <select id="imageMode">
                            <option value="crop" selected>裁剪</option>
                            <option value="stretch">拉伸</option>
                            <option value="fitWidth">适应宽度</option>
                            <option value="fitHeight">适应高度</option>
                        </select>
                    </div>
                </div>
                <div class="param-item">
                    <label>输出格式:</label>
                    <div class="input-group">
                        <select id="outputFormat">
                            <option value="image/jpeg" selected>JPEG</option>
                            <option value="image/png">PNG</option>
                        </select>
                    </div>
                </div>
                <div class="param-item">
                    <label>字体选择:</label>
                    <div class="input-group">
                        <select id="fontFamily">
                            <option value="Arial" selected>Arial</option>
                            <option value="Times New Roman">Times New Roman</option>
                            <option value="Georgia">Georgia</option>
                            <option value="Helvetica">Helvetica</option>
                        </select>
                    </div>
                </div>
                <div class="param-item">
                    <label>文字对齐:</label>
                    <div class="input-group">
                        <select id="textAlign">
                            <option value="left" selected>左对齐</option>
                            <option value="center">居中</option>
                            <option value="right">右对齐</option>
                        </select>
                    </div>
                </div>
                <div class="param-item">
                    <label>预览缩放:</label>
                    <div class="input-group">
                        <select id="previewScale">
                            <option value="0.25">25%</option>
                            <option value="0.5" selected>50%</option>
                            <option value="0.75">75%</option>
                            <option value="1">100%</option>
                            <option value="1.25">125%</option>
                            <option value="1.5">150%</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="download-group">
                <button onclick="downloadAll()"><i class="fas fa-download"></i> 下载全部</button>
                <select id="downloadMode">
                    <option value="zip" selected>打包为ZIP</option>
                    <option value="individual">逐个下载</option>
                </select>
            </div>
            <button onclick="clearAllFiles()"><i class="fas fa-trash"></i> 清空所有</button>
            <button onclick="resetDefaults()"><i class="fas fa-undo"></i> 重置默认</button>
        </div>
        <div class="preview" id="previewContainer"></div>
    </div>
    <div id="loading" class="alert alert-info">处理中，请稍候...</div>
    <div id="status" class="status alert" style="display: none;"></div>

    <script>
      
    let images = [];
    let epubFiles = [];

    const defaultParams = {
        titleSize: 160, authorSize: 100, lineSpacing: 100, topSpace: 500, leftMargin: 60, outputWidth: 1860, aspectRatio: 0.75,
        bgColor: '#ffffff', textColor: '#000000', imageMode: 'crop', outputFormat: 'image/jpeg', fontFamily: 'Arial', textAlign: 'left', previewScale: 0.5
    };

    const dropZone = document.getElementById('dropZone');
    const imageInput = document.getElementById('imageInput');

    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }

    function saveParams() {
        const params = {
            titleSize: document.getElementById('titleSize').value,
            authorSize: document.getElementById('authorSize').value,
            lineSpacing: document.getElementById('lineSpacing').value,
            topSpace: document.getElementById('topSpace').value,
            leftMargin: document.getElementById('leftMargin').value,
            outputWidth: document.getElementById('outputWidth').value,
            aspectRatio: document.getElementById('aspectRatio').value,
            bgColor: document.getElementById('bgColor').value,
            textColor: document.getElementById('textColor').value,
            imageMode: document.getElementById('imageMode').value,
            outputFormat: document.getElementById('outputFormat').value,
            fontFamily: document.getElementById('fontFamily').value,
            textAlign: document.getElementById('textAlign').value,
            previewScale: document.getElementById('previewScale').value
        };
        localStorage.setItem('kindleCoverParams', JSON.stringify(params));
    }

    function loadParams() {
        const savedParams = JSON.parse(localStorage.getItem('kindleCoverParams')) || defaultParams;
        document.getElementById('titleSize').value = savedParams.titleSize;
        document.getElementById('titleSizeRange').value = savedParams.titleSize;
        document.getElementById('authorSize').value = savedParams.authorSize;
        document.getElementById('authorSizeRange').value = savedParams.authorSize;
        document.getElementById('lineSpacing').value = savedParams.lineSpacing;
        document.getElementById('lineSpacingRange').value = savedParams.lineSpacing;
        document.getElementById('topSpace').value = savedParams.topSpace;
        document.getElementById('topSpaceRange').value = savedParams.topSpace;
        document.getElementById('leftMargin').value = savedParams.leftMargin;
        document.getElementById('leftMarginRange').value = savedParams.leftMargin;
        document.getElementById('outputWidth').value = savedParams.outputWidth;
        document.getElementById('outputWidthRange').value = savedParams.outputWidth;
        document.getElementById('aspectRatio').value = savedParams.aspectRatio;
        document.getElementById('aspectRatioRange').value = savedParams.aspectRatio;
        document.getElementById('bgColor').value = savedParams.bgColor;
        document.getElementById('textColor').value = savedParams.textColor;
        document.getElementById('imageMode').value = savedParams.imageMode;
        document.getElementById('outputFormat').value = savedParams.outputFormat;
        document.getElementById('fontFamily').value = savedParams.fontFamily;
        document.getElementById('textAlign').value = savedParams.textAlign;
        document.getElementById('previewScale').value = savedParams.previewScale;
        updatePreviewScale();
    }

    window.addEventListener('load', loadParams);

    function bindInputAndRange(numberId, rangeId) {
        const numberInput = document.getElementById(numberId);
        const rangeInput = document.getElementById(rangeId);
        numberInput.addEventListener('input', () => {
            rangeInput.value = numberInput.value;
            debouncedUpdateAllPreviews();
            saveParams();
        });
        rangeInput.addEventListener('input', () => {
            numberInput.value = rangeInput.value;
            debouncedUpdateAllPreviews();
            saveParams();
        });
    }

    bindInputAndRange('titleSize', 'titleSizeRange');
    bindInputAndRange('authorSize', 'authorSizeRange');
    bindInputAndRange('lineSpacing', 'lineSpacingRange');
    bindInputAndRange('topSpace', 'topSpaceRange');
    bindInputAndRange('leftMargin', 'leftMarginRange');
    bindInputAndRange('outputWidth', 'outputWidthRange');
    bindInputAndRange('aspectRatio', 'aspectRatioRange');

    ['bgColor', 'textColor', 'imageMode', 'outputFormat', 'fontFamily', 'textAlign'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => {
            debouncedUpdateAllPreviews();
            saveParams();
        });
    });

    document.getElementById('previewScale').addEventListener('change', () => {
        updatePreviewScale();
        saveParams();
    });

    function updatePreviewScale() {
        const scale = document.getElementById('previewScale').value;
        document.documentElement.style.setProperty('--preview-scale', scale);
        updateAllPreviews();
    }

    dropZone.addEventListener('click', () => imageInput.click());
    dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); handleFileUpload(e.dataTransfer.files); });
    imageInput.addEventListener('change', (e) => handleFileUpload(e.target.files));

    async function handleFileUpload(files) {
        if (!files || files.length === 0) { showStatus('请至少选择一个文件！', 'danger'); return; }
        const validFiles = Array.from(files).filter(file => {
            const isImage = file.type.startsWith('image/');
            const isEpub = file.name.toLowerCase().endsWith('.epub');
            return isImage || isEpub;
        });
        if (validFiles.length === 0) { showStatus('没有有效的图片或EPUB文件！', 'danger'); return; }
        if (validFiles.length !== files.length) { showStatus('只支持图片和EPUB文件，已过滤掉其他文件！', 'warning'); }

        const newEpubFiles = validFiles.filter(file => file.name.toLowerCase().endsWith('.epub'));
        epubFiles = [...epubFiles, ...newEpubFiles.filter(f => !epubFiles.some(existing => existing.name === f.name))];

        const previewContainer = document.getElementById('previewContainer');
        showLoading(true);

        for (let i = 0; i < validFiles.length; i++) {
            const file = validFiles[i];
            try {
                if (file.type.startsWith('image/')) await processImageFile(file, images.length + i);
                else if (file.name.toLowerCase().endsWith('.epub')) await processEpubFile(file, images.length + i);
            } catch (error) { showStatus(`处理文件 ${file.name} 时出错: ${error.message}`, 'danger'); }
        }
        updateEpubOptions();
        showLoading(false);
    }

    function processImageFile(file, index) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            const filename = file.name.split('.')[0];
            const [title, author] = filename.split('-').length > 1 ? filename.split('-') : [filename, '未知作者'];
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    images[index] = { img, title: title.trim(), author: author.trim(), filename, imageMode: document.getElementById('imageMode').value, cropX: 0.5, cropY: 0.5, epubIndex: -1 };
                    createPreviewItem(index);
                    resolve();
                };
                img.onerror = () => reject(new Error(`无法加载图片: ${file.name}`));
                img.src = e.target.result;
            };
            reader.onerror = () => reject(new Error(`读取图片文件失败: ${file.name}`));
            reader.readAsDataURL(file);
        });
    }

    async function processEpubFile(file, index) {
        try {
            const zip = new JSZip();
            await zip.loadAsync(file);
            const coverCandidates = await findCoverCandidates(zip);
            if (coverCandidates.length === 0) throw new Error(`无法在 ${file.name} 中找到封面图片`);

            let selectedCoverDataUrl = coverCandidates.length === 1 ? coverCandidates[0].dataUrl : await selectCoverFromCandidates(coverCandidates, file.name);
            if (!selectedCoverDataUrl) return;

            const img = await loadImageWithTimeout(selectedCoverDataUrl, file.name, 10000);
            const filename = file.name.split('.')[0];
            const [title, author] = filename.split('-').length > 1 ? filename.split('-') : [filename, '未知作者'];
            images[index] = { img, title: title.trim(), author: author.trim(), filename, imageMode: document.getElementById('imageMode').value, cropX: 0.5, cropY: 0.5, epubIndex: epubFiles.findIndex(f => f.name === file.name) };
            createPreviewItem(index);
        } catch (error) { throw error; }
    }

    function loadImageWithTimeout(src, filename, timeoutMs) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const timeout = setTimeout(() => reject(new Error(`加载封面图片超时 (${filename})`)), timeoutMs);
            img.onload = () => { clearTimeout(timeout); resolve(img); };
            img.onerror = () => { clearTimeout(timeout); reject(new Error(`无法加载EPUB封面图片: ${filename}`)); };
            img.src = src;
        });
    }

    async function findCoverCandidates(zip) {
        const opfFile = Object.keys(zip.files).find(file => file.toLowerCase().endsWith('.opf'));
        if (!opfFile) return [];
        const opfText = await zip.file(opfFile).async("string");
        const parser = new DOMParser();
        const doc = parser.parseFromString(opfText, "application/xml");
        const candidates = [];
        const basePath = opfFile.substring(0, opfFile.lastIndexOf("/") + 1);

        const coverMeta = doc.querySelector('meta[name="cover"]');
        if (coverMeta) {
            const coverId = coverMeta.getAttribute("content");
            const coverItem = doc.querySelector(`item[id="${coverId}"]`);
            if (coverItem) await addCandidateIfImage(zip, basePath + coverItem.getAttribute("href"), candidates);
        }

        const items = doc.getElementsByTagName("item");
        for (let item of items) {
            const href = basePath + item.getAttribute("href");
            const id = item.getAttribute("id")?.toLowerCase();
            const properties = item.getAttribute("properties");
            if ((id && id.includes("cover")) || properties === "cover-image") await addCandidateIfImage(zip, href, candidates);
        }

        if (candidates.length === 0) {
            for (const filePath of Object.keys(zip.files)) {
                if (/cover\.(jpe?g|png)$/i.test(filePath)) await addCandidateIfImage(zip, filePath, candidates);
            }
        }
        return candidates;
    }

    async function addCandidateIfImage(zip, path, candidates) {
        const file = zip.file(path);
        if (file) {
            const mimeType = path.toLowerCase().endsWith('.png') ? 'image/png' : 'image/jpeg';
            const blob = await file.async("blob");
            const dataUrl = await blobToDataURL(new Blob([blob], { type: mimeType }));
            candidates.push({ path, dataUrl });
        }
    }

    function blobToDataURL(blob) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });
    }

    async function selectCoverFromCandidates(candidates, epubName) {
        return new Promise((resolve) => {
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.innerHTML = `
                <div class="modal-dialog modal-dialog-centered">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">选择 ${epubName} 的封面图片</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div id="coverOptions" style="overflow-y: auto; max-height: 400px;"></div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-primary" id="confirmCover"><i class="fas fa-check"></i> 确认</button>
                            <button class="btn btn-secondary" data-bs-dismiss="modal"><i class="fas fa-times"></i> 取消</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            const coverOptions = modal.querySelector('#coverOptions');
            let selectedIndex = 0;
            candidates.forEach((candidate, i) => {
                const div = document.createElement('div');
                div.className = 'cover-option';
                div.innerHTML = `<img src="${candidate.dataUrl}" alt="候选封面 ${i + 1}"><p>${candidate.path}</p>`;
                if (i === 0) div.classList.add('selected');
                div.onclick = () => { coverOptions.querySelectorAll('.cover-option').forEach(opt => opt.classList.remove('selected')); div.classList.add('selected'); selectedIndex = i; };
                coverOptions.appendChild(div);
            });

            const confirmBtn = modal.querySelector('#confirmCover');
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
            confirmBtn.onclick = () => { bsModal.hide(); modal.remove(); resolve(candidates[selectedIndex].dataUrl); };
            modal.addEventListener('hidden.bs.modal', () => { modal.remove(); resolve(null); }, { once: true });
        });
    }

    function createPreviewItem(index) {
        const item = images[index];
        const container = document.getElementById('previewContainer');
        const div = document.createElement('div');
        div.className = 'preview-item';
        div.innerHTML = `
            <button class="delete-btn" onclick="deletePreviewItem(${index})"><i class="fas fa-trash"></i></button>
            <label><span>书名:</span><input type="text" class="title-input" value="${item.title}"></label>
            <label><span>作者:</span><input type="text" class="author-input" value="${item.author}"></label>
            <label><span>图片处理:</span><select class="image-mode-input" data-index="${index}">
                <option value="crop" ${item.imageMode === 'crop' ? 'selected' : ''}>裁剪</option>
                <option value="stretch" ${item.imageMode === 'stretch' ? 'selected' : ''}>拉伸</option>
                <option value="fitWidth" ${item.imageMode === 'fitWidth' ? 'selected' : ''}>适应宽度</option>
                <option value="fitHeight" ${item.imageMode === 'fitHeight' ? 'selected' : ''}>适应高度</option>
            </select></label>
            <div class="crop-controls" style="display: ${item.imageMode === 'crop' ? 'block' : 'none'};">
                <label><span>水平位置:</span><input type="range" class="crop-x" min="0" max="1" step="0.01" value="${item.cropX}"></label>
                <label><span>垂直位置:</span><input type="range" class="crop-y" min="0" max="1" step="0.01" value="${item.cropY}"></label>
            </div>
            <label><span>替换 EPUB:</span><select class="epub-select" data-index="${index}"></select></label>
            <canvas id="canvas-${index}"></canvas>
        `;
        container.appendChild(div);
        updateEpubOptions();
        updatePreview(index);

        div.querySelector('.title-input').addEventListener('input', (e) => { images[index].title = e.target.value; updatePreview(index); });
        div.querySelector('.author-input').addEventListener('input', (e) => { images[index].author = e.target.value; updatePreview(index); });
        div.querySelector('.image-mode-input').addEventListener('change', (e) => {
            images[index].imageMode = e.target.value;
            div.querySelector('.crop-controls').style.display = e.target.value === 'crop' ? 'block' : 'none';
            updatePreview(index);
        });
        div.querySelector('.crop-x').addEventListener('input', (e) => { images[index].cropX = parseFloat(e.target.value); updatePreview(index); });
        div.querySelector('.crop-y').addEventListener('input', (e) => { images[index].cropY = parseFloat(e.target.value); updatePreview(index); });
        div.querySelector('.epub-select').addEventListener('change', (e) => { images[index].epubIndex = parseInt(e.target.value); });
    }

    function updatePreview(index) {
        const item = images[index];
        if (!item) return;
        const canvas = document.getElementById(`canvas-${index}`);
        const ctx = canvas.getContext('2d');
        const outputWidth = parseInt(document.getElementById('outputWidth').value);
        const aspectRatio = parseFloat(document.getElementById('aspectRatio').value);
        const outputHeight = Math.round(outputWidth / aspectRatio);
        canvas.width = outputWidth;
        canvas.height = outputHeight;

        const titleSize = parseInt(document.getElementById('titleSize').value);
        const authorSize = parseInt(document.getElementById('authorSize').value);
        const lineSpacing = parseInt(document.getElementById('lineSpacing').value);
        const topSpace = parseInt(document.getElementById('topSpace').value);
        const leftMargin = parseInt(document.getElementById('leftMargin').value);
        const bgColor = document.getElementById('bgColor').value;
        const textColor = document.getElementById('textColor').value;
        const imageMode = item.imageMode;
        const fontFamily = document.getElementById('fontFamily').value;
        const textAlign = document.getElementById('textAlign').value;

        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, outputWidth, outputHeight);

        const imageHeight = outputHeight - topSpace;
        const imageWidth = outputWidth;
        if (imageMode === 'crop') {
            let sx, sy, sWidth, sHeight;
            const imgRatio = item.img.width / item.img.height;
            const targetRatio = imageWidth / imageHeight;
            if (imgRatio > targetRatio) {
                sHeight = item.img.height;
                sWidth = sHeight * targetRatio;
                const maxOffsetX = item.img.width - sWidth;
                sx = maxOffsetX * item.cropX;
                sy = 0;
            } else {
                sWidth = item.img.width;
                sHeight = sWidth / targetRatio;
                const maxOffsetY = item.img.height - sHeight;
                sx = 0;
                sy = maxOffsetY * item.cropY;
            }
            ctx.drawImage(item.img, sx, sy, sWidth, sHeight, 0, topSpace, imageWidth, imageHeight);
        } else if (imageMode === 'stretch') {
            ctx.drawImage(item.img, 0, topSpace, imageWidth, imageHeight);
        } else if (imageMode === 'fitWidth') {
            const scale = imageWidth / item.img.width;
            const newHeight = item.img.height * scale;
            const offsetY = topSpace + (imageHeight - newHeight) / 2;
            ctx.drawImage(item.img, 0, offsetY, imageWidth, newHeight);
        } else if (imageMode === 'fitHeight') {
            const scale = imageHeight / item.img.height;
            const newWidth = item.img.width * scale;
            const offsetX = (imageWidth - newWidth) / 2;
            ctx.drawImage(item.img, offsetX, topSpace, newWidth, imageHeight);
        }

        ctx.fillStyle = textColor;
        ctx.textAlign = textAlign;
        const textMargin = 40;
        const totalTextHeight = titleSize + authorSize + lineSpacing;
        let adjustedTitleSize = titleSize, adjustedAuthorSize = authorSize, adjustedLineSpacing = lineSpacing;
        const availableHeight = topSpace - 2 * textMargin;
        if (totalTextHeight > availableHeight) {
            const scaleFactor = availableHeight / totalTextHeight;
            adjustedTitleSize = titleSize * scaleFactor;
            adjustedAuthorSize = authorSize * scaleFactor;
            adjustedLineSpacing = lineSpacing * scaleFactor;
        }
        const textBlockHeight = adjustedTitleSize + adjustedLineSpacing + adjustedAuthorSize;
        const textStartY = textMargin + (availableHeight - textBlockHeight) / 2;
        const textX = textAlign === 'left' ? leftMargin : textAlign === 'center' ? outputWidth / 2 : outputWidth - leftMargin;
        ctx.font = `bold ${adjustedTitleSize}px ${fontFamily}`;
        ctx.fillText(item.title.trim(), textX, textStartY + adjustedTitleSize);
        ctx.font = `${adjustedAuthorSize}px ${fontFamily}`;
        ctx.fillText(item.author.trim(), textX, textStartY + adjustedTitleSize + adjustedLineSpacing + adjustedAuthorSize);
    }

    function updateAllPreviews() {
        images.forEach((_, index) => updatePreview(index));
    }

    const debouncedUpdateAllPreviews = debounce(updateAllPreviews, 100);

    async function downloadAll() {
        if (!images.length) { showStatus('请先上传文件！', 'danger'); return; }
        const mode = document.getElementById('downloadMode').value;
        const format = document.getElementById('outputFormat').value;
        showLoading(true);

        if (mode === 'individual') {
            for (let i = 0; i < images.length; i++) {
                const item = images[i];
                const canvas = document.getElementById(`canvas-${i}`);
                const quality = format === 'image/jpeg' ? 0.9 : 1.0;
                const imageLink = document.createElement('a');
                imageLink.download = `${item.title}-${item.author}-kindle.${format.split('/')[1]}`;
                imageLink.href = canvas.toDataURL(format, quality);
                document.body.appendChild(imageLink);
                imageLink.click();
                document.body.removeChild(imageLink);

                if (item.epubIndex !== -1 && epubFiles[item.epubIndex]) {
                    const epubFile = epubFiles[item.epubIndex];
                    showStatus(`处理中：${epubFile.name} (${i + 1}/${images.length})...`);
                    try {
                        const coverBlob = await new Promise(resolve => canvas.toBlob(blob => resolve(blob), format, quality));
                        const newEpubBlob = await processSingleEpub(epubFile, coverBlob, format, item.title, item.author);
                        const epubLink = document.createElement("a");
                        // 修改文件名，添加 .kindle 后缀
                        const baseName = epubFile.name.split('.')[0]; // 去掉 .epub
                        epubLink.download = `${item.title}-${baseName}.kindle.epub`;
                        epubLink.href = URL.createObjectURL(newEpubBlob);
                        document.body.appendChild(epubLink);
                        epubLink.click();
                        document.body.removeChild(epubLink);
                    } catch (error) { showStatus(`处理 ${epubFile.name} 时出错：${error.message}`, "danger"); showLoading(false); return; }
                }
                if (i === images.length - 1) setTimeout(() => showLoading(false), 500);
            }
            showStatus("全部完成！文件已下载。", "success");
        } else if (mode === 'zip') {
            const zip = new JSZip();
            const promises = images.map(async (item, i) => {
                const canvas = document.getElementById(`canvas-${i}`);
                const quality = format === 'image/jpeg' ? 0.9 : 1.0;
                const imageBlob = await new Promise(resolve => canvas.toBlob(blob => resolve(blob), format, quality));
                zip.file(`${item.title}-${item.author}-kindle.${format.split('/')[1]}`, imageBlob);
                if (item.epubIndex !== -1 && epubFiles[item.epubIndex]) {
                    const epubFile = epubFiles[item.epubIndex];
                    showStatus(`处理中：${epubFile.name} (${i + 1}/${images.length})...`);
                    const coverBlob = await new Promise(resolve => canvas.toBlob(blob => resolve(blob), format, quality));
                    const newEpubBlob = await processSingleEpub(epubFile, coverBlob, format, item.title, item.author);
                    // 修改文件名，添加 .kindle 后缀
                    const baseName = epubFile.name.split('.')[0]; // 去掉 .epub
                    zip.file(`${item.title}-${baseName}.kindle.epub`, newEpubBlob);
                }
            });
            await Promise.all(promises);
            zip.generateAsync({ type: 'blob' }).then((content) => {
                saveAs(content, 'kindle_output.zip');
                showStatus("全部完成！文件已打包下载。", "success");
                showLoading(false);
            });
        }
    }

    function resetDefaults() {
        document.getElementById('titleSize').value = defaultParams.titleSize;
        document.getElementById('titleSizeRange').value = defaultParams.titleSize;
        document.getElementById('authorSize').value = defaultParams.authorSize;
        document.getElementById('authorSizeRange').value = defaultParams.authorSize;
        document.getElementById('lineSpacing').value = defaultParams.lineSpacing;
        document.getElementById('lineSpacingRange').value = defaultParams.lineSpacing;
        document.getElementById('topSpace').value = defaultParams.topSpace;
        document.getElementById('topSpaceRange').value = defaultParams.topSpace;
        document.getElementById('leftMargin').value = defaultParams.leftMargin;
        document.getElementById('leftMarginRange').value = defaultParams.leftMargin;
        document.getElementById('outputWidth').value = defaultParams.outputWidth;
        document.getElementById('outputWidthRange').value = defaultParams.outputWidth;
        document.getElementById('aspectRatio').value = defaultParams.aspectRatio;
        document.getElementById('aspectRatioRange').value = defaultParams.aspectRatio;
        document.getElementById('bgColor').value = defaultParams.bgColor;
        document.getElementById('textColor').value = defaultParams.textColor;
        document.getElementById('imageMode').value = defaultParams.imageMode;
        document.getElementById('outputFormat').value = defaultParams.outputFormat;
        document.getElementById('fontFamily').value = defaultParams.fontFamily;
        document.getElementById('textAlign').value = defaultParams.textAlign;
        document.getElementById('previewScale').value = defaultParams.previewScale;
        images.forEach((item) => { item.imageMode = defaultParams.imageMode; item.cropX = 0.5; item.cropY = 0.5; });
        updatePreviewScale();
        updateAllPreviews();
        saveParams();
    }

    function showLoading(show) { document.getElementById('loading').style.display = show ? 'block' : 'none'; }
    function showStatus(message, type = 'info') { const status = document.getElementById('status'); status.textContent = message; status.className = `status alert alert-${type}`; status.style.display = 'block'; }
    function updateEpubOptions() { document.querySelectorAll('.epub-select').forEach((select, index) => { const currentEpubIndex = images[index] ? images[index].epubIndex : -1; select.innerHTML = '<option value="-1">不替换</option>' + epubFiles.map((file, i) => `<option value="${i}" ${i === currentEpubIndex ? 'selected' : ''}>${file.name}</option>`).join(''); }); }
    async function findCoverPath(zip) { const opfFile = Object.keys(zip.files).find(file => file.toLowerCase().endsWith('.opf')); if (!opfFile) throw new Error("未找到 .opf 文件"); const opfText = await zip.file(opfFile).async("string"); const parser = new DOMParser(); const doc = parser.parseFromString(opfText, "application/xml"); const coverMeta = doc.querySelector('meta[name="cover"]'); if (coverMeta) { const coverId = coverMeta.getAttribute("content"); const coverItem = doc.querySelector(`item[id="${coverId}"]`); if (coverItem) return opfFile.substring(0, opfFile.lastIndexOf("/") + 1) + coverItem.getAttribute("href"); } const items = doc.getElementsByTagName("item"); for (let item of items) { const id = item.getAttribute("id")?.toLowerCase(); const href = item.getAttribute("href"); const properties = item.getAttribute("properties"); if ((id && id.includes("cover")) || properties === "cover-image") return opfFile.substring(0, opfFile.lastIndexOf("/") + 1) + href; } const coverGuess = Object.keys(zip.files).find(file => /cover\.(jpe?g|png)$/i.test(file)); if (coverGuess) return coverGuess; throw new Error("未找到封面图片路径"); }
    async function updateMetadata(zip, opfPath, newTitle, newAuthor) { const opfText = await zip.file(opfPath).async("string"); const parser = new DOMParser(); const doc = parser.parseFromString(opfText, "application/xml"); const metadata = doc.getElementsByTagName("metadata")[0]; if (newTitle) { let title = metadata.getElementsByTagName("dc:title")[0]; if (!title) { title = doc.createElementNS("http://purl.org/dc/elements/1.1/", "dc:title"); metadata.appendChild(title); } title.textContent = newTitle; } if (newAuthor) { let creator = metadata.getElementsByTagName("dc:creator")[0]; if (!creator) { creator = doc.createElementNS("http://purl.org/dc/elements/1.1/", "dc:creator"); metadata.appendChild(creator); } creator.textContent = newAuthor; } const serializer = new XMLSerializer(); return '<?xml version="1.0" encoding="UTF-8"?>\n' + serializer.serializeToString(doc); }
    async function processSingleEpub(epubFile, coverBlob, format, newTitle, newAuthor) { const zip = new JSZip(); await zip.loadAsync(await epubFile.arrayBuffer(), { createFolders: true }); if (!zip.files["mimetype"]) zip.file("mimetype", "application/epub+zip", { compression: "STORE" }); const opfPath = Object.keys(zip.files).find(file => file.toLowerCase().endsWith('.opf')); if (!opfPath) throw new Error(`${epubFile.name} 不是有效的 EPUB 文件`); const coverPath = await findCoverPath(zip); zip.file(coverPath, coverBlob, { binary: true }); if (newTitle || newAuthor) { const updatedOpf = await updateMetadata(zip, opfPath, newTitle, newAuthor); zip.file(opfPath, updatedOpf); } return await zip.generateAsync({ type: "blob", mimeType: "application/epub+zip", compression: "DEFLATE", compressionOptions: { level: 6 } }); }

    function clearAllFiles() {
        images = [];
        epubFiles = [];
        document.getElementById('previewContainer').innerHTML = '';
        updateEpubOptions();
        showStatus('所有文件已清空！', 'success');
    }

    function deletePreviewItem(index) {
        images.splice(index, 1);
        document.getElementById(`canvas-${index}`).closest('.preview-item').remove();
        images.forEach((item, i) => {
            if (i >= index) {
                const itemDiv = document.getElementById(`canvas-${i}`).closest('.preview-item');
                itemDiv.querySelector('.delete-btn').setAttribute('onclick', `deletePreviewItem(${i})`);
                itemDiv.querySelector('.image-mode-input').setAttribute('data-index', i);
                itemDiv.querySelector('.epub-select').setAttribute('data-index', i);
                itemDiv.querySelector('canvas').id = `canvas-${i}`;
            }
        });
        updateEpubOptions();
        showStatus(`已删除第 ${index + 1} 个文件！`, 'info');
    }

    </script>
</body>
</html>